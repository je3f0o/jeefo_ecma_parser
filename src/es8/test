
zz = `
    zzz
    ${ ff }
qwe
`;

style = `
my-main {
    display: block;
}
	`;
str = `\`${ attrs[i].value }\``;
str = `
ANON_FN
return anonymous.call(this_arg, $ctrls);
`;

str = `[${MARKER}="${this.id}"]`;
a = `
    "${ a }"
`;


//"use strict";
// 12.2 - Primary expressions
// --------------------------

// 12.2.2 - This keyword
this;

// 12.2.3 - Literals
null;
true;
false;
3.14;
'single quote string';
"double quote string";
/*
assignment_expression = computed = static = value = expr = str = 2;
object = o = {};
spread_element = id = [];
*/

// 12.2.5 - Array initializer
[];
[,,,];
[assignment_expression]; // optional ,
[...spread_element]; // optional ,
[, expr, ...spread_element]; // recursion

// 12.2.6 - Object initializer
o = {
    static,
    * gen () {},

    3.14   : value,
    "str"  : value,
    await  : value,
    [true] : value,

    3.14   () {},
    "str"  () {},
    async  () {},
    [true] () {},

    get 3.14  () {},
    get "str" () {},
    get async () {},
    get [str] () {},

    set 3.14  (v) {},
    set "str" (v) {},
    set await (v) {},
    set [str] (v) {},

    async 3.14       () {},
    async "str"      () {},
    async await      () {},
    async [computed] () {},
};

// 12.15.5 - Destructuring assignment
[, id, id = value, {} = {}, [] = [], [], o.p, ...rest] = [,,[]];
({
    id,
    id : id,
    id : { z = 2 },
    id : { [prop] : id },
    id : [, id, id = value, {} = {}, [] = [], [], o.p, ...rest],
    id = 123
} = {});

o = { z : {}, i : [2 > {}] };


3..property;
//super.property = assignment_expression;
object.property = assignment_expression;

id_ref = assignment_expression;
fn = function       () {};
fn = function await () {};
fn = function yield () {};

async (
    p1, {}, [],
    p2 = 1,
    {} = {},
    [, id, id = value, {} = {}, [] = [], [], ...rest] = [],
    [...[]] = [],
    [...{}] = []
) => {};

() => {};
(p1, {}, [], p2 = 1, {} = {}, [] = []) => {};

fn();

// Statements
var   let = 2;
let   $var;
const $var = value;

let [] = [];
let [,] = [];
let [,a] = [];
let [,[]] = [];

let { prop = default_value } = {};
let { prop:binding_id = default_value, a } = {};
let { prop:{ nested } } = {};
let { prop:[] } = {};
let { [computed]:[] } = {};

// Functions and class
async function async_fn ({ a : s }) { }
async_fn = async function () { await fn(); };
async_fn = async function yield () { await fn(); };

gen = function * () { yield 1; };
gen = function * await () { yield 2; };

class EmptyClass {}
A = class {};
A = class extends B {};
A = class extends null {};
A = class A extends B {};

fn()[a] = 2;

class A extends B {
    ;
    3.14       () {}
    "str"      () {}
    static     () {}
    // Getters
    get 3.14       () {}
    get "str"      () {}
    get static     () {}
    get [computed] () {}
    // Setter
    set 3.14       (v) {}
    set "str"      (v) {}
    set static     (v) {}
    set [computed] (v) {}
    // Statics
    static 3.14       () {}
    static "str"      () {}
    static static     () {}
    static [computed] () {}
    // Static getters
    static get 3.14       () {}
    static get "str"      () {}
    static get static     () {}
    static get [computed] () {}
    // Static setters
    static set 3.14       (v) {}
    static set "str"      (v) {}
    static set static     (v) {}
    static set [computed] (v) {}
}

for (var i in []) {}
for (var i = 2 in []) {}
for (let i in []) {}
for (let [] in []) {}
for (const i in []) {}
for (const [] in []) {}
for (i in []) {}

for (var i of []) {}
for (let i of []) {}
for (let [] of []) {}
for (const i of []) {}
for (const [] of []) {}
for (o in []) {}

for (var i = 2;;) {}
for (let i = 2;;) {}
for (const i = 2;;) {}
for (;;) {}
for (i = 0, len = 10;;) {}

a,b,c;

label :
while (false) {}

